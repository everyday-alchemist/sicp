;; These are all of the exercises I felt to be worth completing during my
;; reading of SICP Chapter 1.

;;   Exercise 1.3: Define a procedure that takes three numbers as
;;   arguments and returns the sum of the squares of the two larger
;;   numbers.
(define (square x) (* x x))
(define (sum-of-squares x y) (+ (square x) (square y)))
(define (sos-larger x y z)
  (if (> x y)
      (if (> y z)
          (sum-of-squares x y)
          (sum-of-squares x z))
      (if (> x z)
          (sum-of-squares x y)
          (sum-of-squares y z))))

;; I got this answer from the internet. It looks a little nicer because there is
;; only one conditional, but my answer does fewer comparisons in the worst case.
(define (internets-sos x y z)
  (cond ((and (>= (+ x y) (+ y z)) (>= (+ x y) (+ x z))) (sum-of-squares x y))
        ((and (>= (+ x z) (+ x y)) (>= (+ x z) (+ y z))) (sum-of-squares x z))
        (else (sum-of-squares y z))))

;;   *Exercise 1.5:* Ben Bitdiddle has invented a test to determine
;;   whether the interpreter he is faced with is using
;;   applicative-order evaluation or normal-order evaluation.  He
;;   defines the following two procedures:
(define (p) (p))
(define (test x y)
  (if (= x 0)
      0
      y))

(test 0 (p))

;; Applicative Order - loop forever
;; (test 0 (p))
;; (test 0 (p))
;; (test 0 (p))
;; ...

;; Normal Order
;; (test 0 (p))
;; (if (= 0 0)
;;     0
;;     (p))
;;
;; (if #t
;;     0
;;     (p))
;;
;; 0

;;   Exercise 1.6: Alyssa P. Hacker doesn't see why `if' needs to be
;;   provided as a special form.  "Why can't I just define it as an
;;   ordinary procedure in terms of `cond'?" she asks.  Alyssa's friend
;;   Eva Lu Ator claims this can indeed be done, and she defines a new
;;   version of `if':
;;        (define (new-if predicate then-clause else-clause)
;;          (cond (predicate then-clause)
;;                (else else-clause)))
;;
;;   Delighted, Alyssa uses `new-if' to rewrite the square-root program:
;;
;;        (define (sqrt-iter guess x)
;;          (new-if (good-enough? guess x)
;;                  guess
;;                  (sqrt-iter (improve guess x)
;;                             x)))
;;
;;   What happens when Alyssa attempts to use this to compute square
;;   roots?  Explain.
;;
;; Answer:
;;     The arguments of new-if must be evaluated before the body can be applied.
;; This means new-sqrt will be evaluated each time new-if is evaluated which
;; will cause and infinite chain of new-ifs to be generated without any of them
;; ever being evaluated.

;; Exercise 1.9: Each of the following two procedures defines a
;; method for adding two positive integers in terms of the procedures
;; `inc', which increments its argument by 1, and `dec', which
;; decrements its argument by 1.
;;
;;     (define (+ a b)
;;        (if (= a 0)
;;            b
;;            (inc (+ (dec a) b))))
;;
;;      (define (+ a b)
;;        (if (= a 0)
;;            b
;;            (+ (dec a) (inc b))))
;;
;; Using the substitution model, illustrate the process generated by
;; each procedure in evaluating `(+ 4 5)'.  Are these processes
;; iterative or recursive?
                                        ;
;; process 1 is recursive. The (inc (+ dec a) b) call cannot be evaluated until
;; the base case is reached
;; (+ 4 5)
;; (if (= 4 0)
;;  5
;;  (inc (+ (dec 4) 5)))
;; (inc (+ 3 5))
;; (inc (if (= 3 0)
;;        5
;;        (inc (+ (dec 3) 5)))
;;
;; Process 2 is iterative. Even though + calls itself 'b' acts as a counter and
;; each call does not cascade.
;; (+ 4 5)
;; (if (= 4 0)
;;  5
;;  (+ (dec 4) (inc 5)))
;; (+ (dec 4) (inc 5))
;; (+ 3 6)
;; ...

;;   Exercise 1.11: A function f is defined by the rule that f(n) = n
;;   if n<3 and f(n) = f(n - 1) + 2f(n - 2) + 3f(n - 3) if n>= 3.
;;   Write a procedure that computes f by means of a recursive process.
;;   Write a procedure that computes f by means of an iterative
;;   process.

(define (rec-f n)
  (if (< n 3)
      n
      (+ (rec-f (- n 1))
         (* (rec-f (- n 2)) 2)
         (* (rec-f (- n 3)) 3))))

(define (iter-f n)
  (define (f a b c count)
    (cond ((< n 3) n)
          ((= count n) (+ a (* b 2) (* c 3)))
          (else (f (+ a (* b 2) (* c 3)) a b (+ count 1)))))
  (f 2 1 0 3))

;;   Exercise 1.12: The following pattern of numbers is called "Pascal's
;;   triangle".
;;
;;                1
;;              1   1
;;            1   2   1
;;          1   3   3   1
;;        1   4   6   4   1
;;
;;   The numbers at the edge of the triangle are all 1, and each number
;;   inside the triangle is the sum of the two numbers above it.(4)
;;   Write a procedure that computes elements of Pascal's triangle by
;;   means of a recursive process.

;; NOTE: This solution assumes we are getting valid input.
(define (pascal col row)
  (cond ((or (= row 0) (= row 1)) 1)
        ((or (= col 0) (= col row)) 1)
        (else (+ (pascal (- col 1) (- row 1))
                 (pascal col (- row 1))))))

;;    Exercise 1.16: Design a procedure that evolves an iterative
;;    exponentiation process that uses successive squaring and uses a
;;    logarithmic number of steps, as does `fast-expt'.  (Hint: Using the
;;    observation that (b^(n/2))^2 = (b^2)^(n/2), keep, along with the
;;    exponent n and the base b, an additional state variable a, and
;;    define the state transformation in such a way that the product a
;;    b^n is unchanged from state to state.  At the beginning of the
;;    process a is taken to be 1, and the answer is given by the value
;;    of a at the end of the process.  In general, the technique of
;;    defining an "invariant quantity" that remains unchanged from state
;;    to state is a powerful way to think about the design of iterative
;;    algorithms.)

(define (square x) (* x x))
(define (fast-expt b n)
  (cond ((= n 0) 1)
        ((even? n) (square (fast-expt b (/ n 2))))
        (* b (fast-expt b (- n 1)))))

(define (iter-expt b n)
  (define (iter B N A)
    (cond ((= N 0) 1)
          ((= N 1) (* B A))
          ((even? N) (iter (* B B) (/ N 2) A))
          (else (iter B (- N 1) (* A B)))))
  (iter b n 1))

;;   Exercise 1.17: The exponentiation algorithms in this section are
;;   based on performing exponentiation by means of repeated
;;   multiplication.  In a similar way, one can perform integer
;;   multiplication by means of repeated addition.  The following
;;   multiplication procedure (in which it is assumed that our language
;;   can only add, not multiply) is analogous to the `expt' procedure:
;;
;;      (define (* a b)
;;        (if (= b 0)
;;            0
;;            (+ a (* a (- b 1)))))
;;
;;   This algorithm takes a number of steps that is linear in `b'.  Now
;;   suppose we include, together with addition, operations `double',
;;   which doubles an integer, and `halve', which divides an (even)
;;   integer by 2.  Using these, design a multiplication procedure
;;   analogous to `fast-expt' that uses a logarithmic number of steps.

(define (fast-mult a b)
  (define (double x) (+ x x))
  (define (halve x) (/ x 2))
  (cond ((= b 0) 0)
        ((even? b) (double (fast-mult a (halve b))))
        (else (+ a (fast-mult a (- b 1))))))

;;   Exercise 1.18: Using the results of Exercise 1-16 and
;;   Exercise 1-17, devise a procedure that generates an
;;   iterative process for multiplying two integers in terms of adding,
;;   doubling, and halving and uses a logarithmic number of steps.

;; NOTE: I use local scoping which has not been covered by SICP at this point
(define (iter-mult a b)
  (define (double x) (+ x x))
  (define (halve x) (/ x 2))
  (define (iter x y)
    (cond ((= y 0) 0)
          ((= y 1) x)
          ((even? y) (iter (double x) (halve y)))
          (else (iter (+ x a) (- y 1)))))
  (iter a b))

;;   Exercise 1.19: There is a clever algorithm for computing the
;;   Fibonacci numbers in a logarithmic number of steps.  Recall the
;;   transformation of the state variables a and b in the `fib-iter'
;;   process of section *Note 1-2-2::: a <- a + b and b <- a.  Call
;;   this transformation T, and observe that applying T over and over
;;   again n times, starting with 1 and 0, produces the pair _Fib_(n +
;;   1) and _Fib_(n).  In other words, the Fibonacci numbers are
;;   produced by applying T^n, the nth power of the transformation T,
;;   starting with the pair (1,0).  Now consider T to be the special
;;   case of p = 0 and q = 1 in a family of transformations T_(pq),
;;   where T_(pq) transforms the pair (a,b) according to a <- bq + aq +
;;   ap and b <- bp + aq.  Show that if we apply such a transformation
;;   T_(pq) twice, the effect is the same as using a single
;;   transformation T_(p'q') of the same form, and compute p' and q' in
;;   terms of p and q.  This gives us an explicit way to square these
;;   transformations, and thus we can compute T^n using successive
;;   squaring, as in the `fast-expt' procedure.  Put this all together
;;   to complete the following procedure, which runs in a logarithmic
;;   number of steps:(5)
;;
;;      (define (fib n)
;;        (fib-iter 1 0 0 1 n))
;;
;;      (define (fib-iter a b p q count)
;;        (cond ((= count 0) b)
;;              ((even? count)
;;               (fib-iter a
;;                         b
;;                         <??>      ; compute p'
;;                         <??>      ; compute q'
;;                         (/ count 2)))
;;              (else (fib-iter (+ (* b q) (* a q) (* a p))
;;                              (+ (* b p) (* a q))
;;                              p
;;                              q
;;                              (- count 1)))))

(define (fib-iter a b p q count)
  (cond ((= count 0) b)
        ((even? count)
        (fib-iter a
                  b
                  (+ (square p) (square q))
                  (+ (* p q 2) (square q))
                  (/ count 2)))
        (else (fib-iter (+ (* b q) (* a q) (* a p))
                        (+ (* b p) (* a q))
                        p
                        q
                        (- count 1)))))

;;   Exercise 1.20: The process that a procedure generates is of
;;   course dependent on the rules used by the interpreter.  As an
;;   example, consider the iterative `gcd' procedure given above.
;;   Suppose we were to interpret this procedure using normal-order
;;   evaluation, as discussed in section *Note 1-1-5::.  (The
;;   normal-order-evaluation rule for `if' is described in *Note
;;   Exercise 1-5::.)  Using the substitution method (for normal
;;   order), illustrate the process generated in evaluating `(gcd 206
;;   40)' and indicate the `remainder' operations that are actually
;;   performed.  How many `remainder' operations are actually performed
;;   in the normal-order evaluation of `(gcd 206 40)'?  In the
;;   applicative-order evaluation?
;;
;;   (define (gcd a b)
;;     (if (= b 0)
;;        a
;;        (gcd b (remainder a b))))

;; Normal:
;; (gcd 206 40)
;;
;; (if (= 40 0)
;;  206
;;  (gcd 40 (remainder 206 40)))
;;
;; (gcd 40 (remainder 206 40))
;;
;; (if (= (remainder 206 40) 0) 1
;;  40
;;  (gcd (remainder 206 40) (remainder 40 (remainder 206 40))))
;;
;;  (gcd (remainder 206 40)
;;       (remainder 40
;;                 (remainder 206 40))))
;;
;; (if (= (remainder 40 (remainder 206 40)) 0) 2+1 = 3 total calls
;;    ...
;;   (gcd (remainder 40
;;                    (remainder 206 40))
;;       (remainder
;;        (remainder 40
;;                    (remainder 206 40))
;;         (remainder 206 40)))
;;
;; (if (= (remainder (remainder 40 (remainder 206 40)) (remainder 206 40)) 0) 3+4 = 7 total calls
;;   ...
;;   (gcd (remainder (remainder 40 (remainder 206 40)) (remainder 206 40))
;;        (remainder (remainder 40 (remainder 206 40))
;;                   (remainder (remainder 40 (remainder 206 40)) (remainder 206 40)))))
;;
;; (if (= (chain containing 7 calls to remainder which evaluates to 0) 0) 7+7 = 14 total calls
;;   (remainder (remainder 40 (remainder 206 40)) (remainder 206 40))) 14+4 = 18 total calls
;;   ...
;;
;; Applicative:
;; (gcd 206 40)
;;
;; (if (= 40 0)
;;   206
;;   (gcd 40 (remainder 206 40)))
;;
;;  (gcd 40 (remainder 206 40)) 1
;;
;;  (gcd 40 6)
;;
;; (if (= 6 0)
;;   40
;;   (gcd 6 (remainder 40 6)))
;;
;; (gcd 6 4) 1+1 = 2 total calls
;;
;; (if (= 4 0)
;;  6
;;  (gcd 4 (remainder 6 4)))
;;
;; (gcd 4 2) 2+1 = 3 total calls
;;
;; (if (= 2 0)
;;  4
;;  (gcd 2 (remainder 4 2))) 3+1 = 4 total calls
;;
;; (gcd 2 0)
;;
;; (if (= 0 0)
;;  2
;;  ...)
;;
;; Normal order: 18 calls
;; Applicative order: 4 calls

;;   Exercise 1.21: Use the `smallest-divisor' procedure to find the
;;   smallest divisor of each of the following numbers: 199, 1999,
;;   19999.

(define (divides? a b)
  (= (remainder b a) 0))

(define (find-divisor n test-divisor)
  (cond ((> (square test-divisor) n) n)
        ((divides? test-divisor n) test-divisor)
        (else (find-divisor n (+ test-divisor 1)))))

(define (smallest-divisor n)
  (find-divisor n 2))

;; (smallest-divisor 199)
;; ...
;; tries numbers up to 15 and then returns 15 because 15^2 > 199
;;
;; (smallest-divisor 1999)
;; ...
;; tries numbers up to 45 and returns 45 because 45^2 > 1999
;;
;; (smallest-divisor 19999)
;; ...
;; tries numbers up to 7 and returns (= (remainder 19999 7) 0)
;;

;; NOTE: this solution is a little janky, but the timing doesn't work with
;; racket and this problem isn't interesting enough to bother fixing it.
(define (prime? n)
  (= n (smallest-divisor n)))

(define (report-prime elapsed-time)
  (display " *** ")
  (display elapsed-time))

(define (start-prime-test n start-time)
  (if (prime? n)
    (report-prime (- (current-milliseconds) start-time))
    null))

(define (timed-prime-test n)
  (newline)
  (display n)
  (start-prime-test n (current-milliseconds)))

(define (search-for-primes n m)
  (timed-prime-test n) ; this is not good, idc, smd
  (cond ((>= n m) #t)
        ((even? n) (search-for-primes (+ n 1) m))
        (else (search-for-primes (+ n 2) m))))

(define (sum term a next b)
  (if (> a b)
      0
      (+ (term a)
        (sum term (next a) next b))))

(define (inc x)
  (+ x 1))

(define (simps-rule f a b n)
  (define h (/ (- b a) n))
  (define (simp-term k)
    (define coef
      (cond ((or (= k 0) (= k n)) 0)
            ((odd? k) 4)
            (else 2)))
    (* coef (f (+ a (* k h)))))
  (* (/ h 3) (sum simp-term 0 inc n)))


(define (sum-iter term a next b)
  (define (iter a total)
    (if (> a b)
        total
        (iter (next a) (+ total (term a)))))
  (iter a 0))

(define (product term a next b)
  (if (> a b)
      1
      (* (term a)
         (product term (next a) next b))))

(define (product-iter term a next b)
  (define (iter a total)
    (if (> a b)
        total
        (iter (next a) (* total (term a)))))
  (iter a 1))

(define (accumulate combiner null-value term a next b)
  (if (> a b)
      null-value
      (combiner (term a)
                (accumulate combiner null-value term (next a) next b))))

(define (acc-iter combiner null-value term a next b)
  (define (iter a total)
    (if (> a b)
        total
        (iter (next a) (combiner (term a) total))))
  (iter a null-value))

(define (filtered-accumulate pred combiner null-value term a next b)
  (cond ((> a b)
         null-value)
        ((pred a)
         (combiner (term a)
                   (filtered-accumulate pred combiner null-value term (next a) next b)))
        (else (filtered-accumulate pred combiner null-value term (next a) next b))))

;; 1.34
;; The interpreter will try to evaluate (2 2) and cause an error.

;; 1.35
(define tolerance 0.00001)

(define (fixed-point f first-guess)
  (define (close-enough? v1 v2)
    (< (abs (- v1 v2)) tolerance))
  (define (try guess)
    (let ((next (f guess)))
      (if (close-enough? guess next)
          next
          (try next))))
  (try first-guess))

(fixed-point (lambda (x) (+ 1 (/ 1 x))) 1)

;; 1.36
(define tolerance 0.00001)

(define (fixed-point f first-guess)
  (define (close-enough? v1 v2)
    (< (abs (- v1 v2)) tolerance))
  (define (try guess)
    (println guess)
    (let ((next (f guess)))
      (if (close-enough? guess next)
          next
          (try next))))
  (try first-guess))

(fixed-point (lambda (x) (/ (log 1000) (log x))) 2) ; 33 guesses

(define (average x y) (/ (+ x y) 2))
(fixed-point (lambda (x) (average x (/ (log 1000) (log x)))) 2) ; 9 guesses

;; 1.37
(define (cont-frac n d k)
  (define (rec count)
    (if (= count k)
        (/ (n count) (d count))
        (/ (n count)
           (+ (d count) (rec (+ count 1))))))
  (rec 0))

;; 10 iterations gives the value 1/phi accurate to 4 decimal places
(cont-frac (lambda (i) 1.0)
           (lambda (i) 1.0)
           10)

(define (iter-cont-frac n d k)
  (define (iter total count)
    (if (= count 0)
        total
        (iter (/ (n count) (+ (d count) total)) (- count 1))))
  (iter 0.0 k))

(iter-cont-frac (lambda (i) 1.0)
                (lambda (i) 1.0)
                10)

;; 1.39
(define (tan-cf x k)
  (iter-cont-frac (lambda (i) (if (= i 1) x (* x x)))
                  (lambda (i) (+ i (- i 1)))
                  10))

;; 1.41
(define (double f)
  (lambda (x) (f (f x))))

(((double (double double)) inc) 5) ; 21

;; 1.42
(define (compose f g)
  (lambda (x) (f (g x))))

;; 1.43
(define (repeated f n)
  (define (iter F N)
    (if (= N 1)
        F
        (iter (lambda (x) (f (f x))) (- N 1))))
    (iter f n))

;; 1.44
;; The exercise says to only take f as a param, but its dumb to hard-code dx
(define (smooth f dx)
  (lambda (x) (/ (+ (f (- x 0.0001))
                    (f (+ x 0.0001)))
                 2)))

(((repeated (lambda (x) (smooth x 0.000001)) 3) square) 8)

;; 1.46
(define (iterative-improve good-enough? improve)
  (define (iter guess)
    (if (good-enough? guess)
        guess
        (iter (improve guess))))
  iter)

(define (sqrt x)
  (define (average x y)
    (/ (+ x y) 2))
  (define (good-enough? guess)
    (< (abs (- (* guess guess) x)) (* x 0.00001)))
  (define (improve guess)
    (average guess (/ x guess)))
  ((iterative-improve good-enough? improve) 1.0))


(define (fixed-point f first-guess)
  (define tolerance 0.00001)
  (define (good-enough? guess)
    (< (abs (- guess (improve guess))) tolerance))
  (define (improve guess)
    (f guess))
  ((iterative-improve good-enough? improve) first-guess))
